



---

layout:     post   				    # 使用的布局（不需要改）
title: 	面试常问		# 标题 
date:       2021-07-19				# 时间
author:     t298						# 作者
header-img: img/wallhaven-j38xpq.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

   - 基础
   - 面试

---

[toc]

### 链表和数组的区别

数组占用的是一块连续的内存区，而链表在内存中，是分散的。数组可以通过下标访问任何一个元素，而链表只能通过节点指针一个个找。但是对于增加数据，数组中会把所有的元素统一向后移动，而链表只需要更改指针对应位置就可以了。



###  list和set的区别

在List中允许插入重复的元素，而在Set中不允许重复元素存在。

List是有序集合，会保留元素插入时的顺序，Set是无序集合。

List可以通过下标来访问，而Set不能



### ArrayList和LinkedList的区别？

ArrayList是实现了**基于动态数组**的数据结构，而LinkedList是**基于链表**的数据结构

对于**随机访问get和set，ArrayList要优于LinkedList**，因为LinkedList要移动指针

LinkedList是个双向链表，它同样可以被当作栈、队列或双端队列来使用



###  java为什么是单继承?

  Java中类不能多继承类是为了安全。因为无论是抽象类还是非抽象类都包含非抽象的方法（非抽象类也可能没有），当类可以多继承类时，被继承的不同的父类可能会有同名同参的方法，如果子类也没有重写这个同名同参的方法，则在子类的实例调用这个方法的时候就会出现冲突。



###  说一下多态

由同一个对象调用，产生不同的行为，这种行为就叫多态。 Java实现多态有三个必要条件：继承、重写、向上转型。



### 说一下重写和重载

重载：一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。



### 创建线程的几种方式

1. 继承Thread类，重写run方法，调用线程对象的start()方法来启动该线程。
2. 实现runnable接口，重写run方法，调用线程对象的start()方法来启动该线程
3. 创建Callable接口的实现类，并实现call()方法，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

采用实现Runnable、Callable接口的方式创建多线程时：

- 优势：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

- 劣势：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

使用继承Thread类的方式创建多线程时

- 优势：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
- 劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。

Runnable和Callable的区别

1. Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
2. Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
3. call方法可以抛出异常，run方法不可以。
4. 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

### 什么是线程安全

当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。

###  说一下io流

根据数据的流向可以分为输入流和输出流，根据字节流和字符流。



- **输入流** ：把数据从`其他设备`上读取到`内存`中的流。
- **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。



- **字节流** ：以字节为单位，读写数据的流。
- **字符流** ：以字符为单位，读写数据的流，只能操作纯字符数据。



###  说一下b+树

- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 父节点存有右孩子的第一个元素的索引。

### HashMap 和 HashTable 区别

HashMap是map接口的实现类，不是线程安全的。它是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null  key 和 null value，而 HashTable 不允许。

HashTable 是线程安全 Collection。HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null  key 和 null value,由于非线程安全，效率上可能高于 Hashtable。

### 浏览器输入百度后发生了什么？

1.域名解析

2.浏览器与服务器建立连接

3.web浏览器发送HTTP请求

4.web服务器处理请求并返回HTTP响应

5.浏览器接收HTTP响应

6.浏览器渲染页面



### 说一下http的请求头有哪些

 Referer：浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL

Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号

Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。

Proxy-Authenticate：代理服务器响应浏览器，要求其提供代理身份验证信息。



###  说一下http

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

### https

**一般http中存在如下问题：**

- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改
- 没有验证对方身份，存在冒充危险

为了解决上述HTTP存在的问题，就用到了HTTPS。

HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

**那么SSL又是什么？**

SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。

TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。



### 浏览器在使用HTTPS传输数据的流程是什么？

1. 首先客户端通过URL访问服务器建立SSL连接。
2. 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
3. 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5. 服务器利用自己的私钥解密出会话密钥。
6. 服务器利用会话密钥加密与客户端之间的通信。



### post和get的区别

- 都包含请求头请求行，post多了请求body。
- get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。
- GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。
- GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。



###  什么是设计模式

解决编程里某类问题的通用模板，总结出来就是设计模式。在软件领域，“四人帮”首次系统化地提出了3大类（创建模式、行为模式、组合模式）共23种经典的可以解决常见软件设计问题的可复用设计方案，为可复用软件设计奠定了一定的理论基础。

- 策略模式：



###  什么是servlet?说一下生命周期

任何一个应用程序，必然包括这三个步骤。其中接收请求和响应请求是共性功能，且没有差异性。访问淘宝和访问京东，都是接收，响应给浏览器的都是JSON数据。于是，大家就把接收和响应两个步骤抽取成Web服务器，但**处理请求的逻辑**是不同的。没关系，**抽取出来做成Servlet，交给程序员自己编写。**

当然，随着后期互联网发展，出现了三层架构，所以一些逻辑就从Servlet抽取出来，分担到Service和Dao。但是Servlet并不擅长往浏览器输出HTML页面，所以出现了JSP。

生命周期：Servlet 加载—>实例化—>服务—>销毁。



### Mysql的锁有哪些？

可以分为**全局锁、表级锁和行锁**三类。

### 说一下事务

在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为*隐式事务*。要手动把多条SQL语句作为一个事务执行，使用`BEGIN`开启一个事务，使用`COMMIT`提交一个事务，这种事务被称为*显式事务*



###  说一下索引

在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。

索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。

使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`，使用列`score`的索引。



### jdbc的操作步骤

加载数据库驱动类
打开数据库连接
执行sql语句
处理返回结果
关闭资源



### 什么是spring?

Spring 是一个开源框架，Spring是于2003 年兴起的一个**轻量级**的Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring 使用基本的 JavaBean 来完成以前只可能由 EJB 完成的事情。

### Spring的生命周期

实例化、属性赋值、初始化、销毁，

###  什么是ioc

IoC 就是**依赖倒置**原则的一种**设计思路**，就**是将原本在程序中自己手动创建对象的控制权，交由 Spring 框架来管理**。Spring 框架负责控制对象的**生命周期**和**对象之间的关系**。IoC 在其他语言中也有应用，并非 Spirng 特有。**ioc 容器实际上就是个 map（key，value），里面存的是各种对象**（在xml里配置的bean节点||repository、service、controller、component）。

**Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。** IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。

**IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的**。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。



### 什么是aop

面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。
    也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？**这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。** 
      一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。

　　



### aop的代理方式

JDK动态代理和CGLIB动态代理。

**JDK 动态代理**只能对实现了接口的类生成代理，而不能针对类.主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。
InvocationHandler 是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。
Proxy 利用 InvocationHandler 动态创建 一个符合某一接口的实例，生成目标类的代理对象。

**CGLIB 是针对类实现代理**，主要是对指定的类生成一个子类，覆盖其中的方法（继承）CGLib 全称为 CodeGeneration Library，是一个强大的高性能，高质量的代码生成类库， 可以在运行期扩展Java 类与实现 Java 接口，CGLib 封装了 asm，可以再运行期动态生成新class。

**CGLIB和 JDK 动态代理相比较：**

JDK 创建代理有一个限制，就是只能为接口创建代理实例， 而对于没有通过接口定义业务方法的类，则可以通过CGLib 创建动态代理。(一个是只能在接口内，另一个在类内)

Spring 在选择用 JDK 还是 CGLiB 的依据：

1. 当 Bean 实现接口时，Spring 就会用 JDK 的动态代理
2. 当 Bean 没有实现接口时，Spring 使用 CGlib 是实现
3. 可以强制使用 CGlib（在 spring 配置中加入<aop:aspectj-autoproxy proxy-target-class=“true”/>



### spring怎么注入bean

通过set方法注入Bean

通过构造方法注入Bean

通过属性去注入Bean



### java中的反射

JDBC利用反射将数据库的表字段映射到java对象的getter/setter方法。



### redis的数据类型

支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。

- 有序集合 zset（sorted-set）相关特性
  1. redis 有序集合 zset 与 无序 set 类型的一样，都是 string 类型的集合元素，且元素不允许重复。
  2. zset 的每个元素都会关联一个 double 类型的分数（score）。redis 就是通过分数来为集合中的成员进行从小到大的排序。
  3. 有序集合的成员是唯一的，但是对应的分数 （score）是可以重复的。

### linux查看日志

命令格式: tail[必要参数][选择参数][文件] 

-f 循环读取 

-q 不显示处理信息 

-v 显示详细的处理信息 

-c<数目> 显示的字节数 

-n<行数> 显示行数 

q, --quiet, --silent 从不输出给出文件名的首部 

-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒

常用命令：pwd,rename,rm,touch,mkdir,cat



### 你自己比较擅长的是那方面呢

我比较擅长学习和总结。互联网这个行业，你要是没有一定的学习能力，你肯定是要被淘汰的。而我是热爱这个行业，一直坚持着博客的更新，不管是新的知识还是工作中遇到的难题，我都会去学习并且总结经验，我也会一直保持我的学习热情。



### 23. 你自己比较擅长的是那方面呢

### 24. 说一下你学习过程中遇到的问题以及你是怎么解决的

